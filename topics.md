let s_b = s in
* Session types (s s_b s z)
* Supercompilation (s s_b s z)
* Functional language implementation (compilation, data parallelism, GPU execution) (s s_b z)
* Dependent types and formal methods (Coq/Agda/Lean, applications to logic, PLs) (s_b s z)
* HoTT (s_b s z)
* Esoteric languages (s z)
* Distributed system design (s_b s z)
* Large-scale/parallel algorithms (cache-oblivious and succinct data structures, graph algorithms, large-scale indexing) (s_b z)
* Combinatorial optimization, linear programming, polyhedra, graph cuts, network flows (s_b z)
* Type and effect systems (modules, polymorphism, algebraic effects) (s_b z)
* Denotational semantics (s_b z)
* Typed/linear/concurrent logics and logic programming (LambdaProlog/Twelf/Celf/Lolli/Oz/Alice/Curry/Mercury, theory, implementation, PL/other applications) (s_b z)
* Hash functions/cryptography/pseudo random number generators (s_b s z)
* Build interpreter/compiler from for a language of interest, e.g. minikanran, datalog, bloom (s_b s s z)
* Applications of metaprogramming, e.g. texture generation, database query optimization, datalog optimization (s_b s s z)
* Incremental computation, e.g. Adapton, Incremental Î»-Calculi via Differentiation, Timely/Differential dataflow (s_b s z)
* Contraptions, theory and implementation (p s z)
